.TH "afcgi.h" 3 "23 Nov 2008" "Version 0" "events" \" -*- nroff -*-
.ad l
.nh
.SH NAME
afcgi.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <events.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBafcgi_hdr\fP"
.br
.ti -1c
.RI "struct \fBafcgi_sess\fP"
.br
.ti -1c
.RI "struct \fBafcgi\fP"
.br
.ti -1c
.RI "struct \fBafcgi::rotbuffer\fP"
.br
.ti -1c
.RI "struct \fBafcgi_binder\fP"
.br
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBafcgi_set_callback\fP(sess, name, cb)   afcgi_set_cb_ ## name(sess, cb)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(*) \fBafcgi_cb\fP (struct afcgi_sess *s, void *arg)"
.br
.ti -1c
.RI "typedef void(*) \fBafcgi_cb_data\fP (struct afcgi_sess *s, void *arg, char *data, int len)"
.br
.ti -1c
.RI "typedef int(*) \fBafcgi_cb_write\fP (struct afcgi_sess *s, void *arg, char *data, int len)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBafcgi_callback_names\fP "
.br
.ti -1c
.RI "enum \fBafcgi_return_status\fP { \fBFCGI_REQUEST_COMPLETE\fP =  0, \fBFCGI_CANT_MPX_CONN\fP =  1, \fBFCGI_OVERLOADED\fP =  2, \fBFCGI_UNKNOWN_ROLE\fP =  3 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBafcgi_init\fP (int maxconn)"
.br
.ti -1c
.RI "int \fBafcgi_bind\fP (char *bind, \fBafcgi_cb\fP on_new, void *arg)"
.br
.ti -1c
.RI "void \fBafcgi_loop\fP (int loop)"
.br
.ti -1c
.RI "static void \fBafcgi_set_arg\fP (struct afcgi_sess *s, void *arg)"
.br
.ti -1c
.RI "void \fBafcgi_want_write\fP (struct afcgi_sess *s)"
.br
.ti -1c
.RI "void \fBafcgi_stop_write\fP (struct afcgi_sess *s)"
.br
.ti -1c
.RI "void \fBafcgi_end\fP (struct afcgi_sess *s, enum \fBafcgi_return_status\fP rs)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "enum \fBafcgi_return_status\fP \fBtm\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "Define Documentation"
.PP 
.SS "#define afcgi_set_callback(sess, name, cb)   afcgi_set_cb_ ## name(sess, cb)"
.PP
set callback 
.PP
\fBParameters:\fP
.RS 4
\fIsess\fP fascgi session identifier 
.br
\fIname\fP callback name 
.br
\fIcb\fP calback pointer 
.RE
.PP

.SH "Typedef Documentation"
.PP 
.SS "typedef void(*) \fBafcgi_cb\fP(struct afcgi_sess *s, void *arg)"
.PP
used for standard afcgi callbacks 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP is afcgi session 
.br
\fIarg\fP is easy argument 
.RE
.PP

.SS "typedef void(*) \fBafcgi_cb_data\fP(struct afcgi_sess *s, void *arg, char *data, int len)"
.PP
used for standard afcgi input callbacks 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP is afcgi session 
.br
\fIarg\fP is easy argument 
.br
\fIdata\fP is buffer containing data 
.br
\fIlen\fP is data length 
.RE
.PP

.SS "typedef int(*) \fBafcgi_cb_write\fP(struct afcgi_sess *s, void *arg, char *data, int len)"
.PP
used for standard afcgi output callbacks 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP is afcgi session 
.br
\fIarg\fP is easy argument 
.br
\fIdata\fP is buffer receiving data 
.br
\fIlen\fP is max data length writable 
.RE
.PP
\fBReturns:\fP
.RS 4
return length writed 
.RE
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBafcgi_callback_names\fP"
.PP
The names of the different callbacks 
.SS "enum \fBafcgi_return_status\fP"
.PP
return status 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIFCGI_REQUEST_COMPLETE \fP\fP
normal end of request. 
.TP
\fB\fIFCGI_CANT_MPX_CONN \fP\fP
rejecting a new request. This happens when a Web server sends concurrent requests over one connection to an application that is designed to process one request at a time per connection. 
.TP
\fB\fIFCGI_OVERLOADED \fP\fP
rejecting a new request. This happens when the application runs out of some resource, e.g. database connections. 
.TP
\fB\fIFCGI_UNKNOWN_ROLE \fP\fP
rejecting a new request. This happens when the Web server has specified a role that is unknown to the application. 
.SH "Function Documentation"
.PP 
.SS "int afcgi_bind (char * bind, \fBafcgi_cb\fP on_new, void * arg)"
.PP
Bind network address or socket 
.PP
\fBParameters:\fP
.RS 4
\fIbind\fP network address or socket (or NULL for stdin) 
.br
\fIon_new\fP callback called for new connexion 
.br
\fIarg\fP easy arg 
.RE
.PP
\fBReturns:\fP
.RS 4
if ok return 0, else return < 0 
.RE
.PP

.SS "void afcgi_end (struct afcgi_sess * s, enum \fBafcgi_return_status\fP rs)"
.PP
afcgi session end 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP afcgi session identifier 
.br
\fIrs\fP return status 
.RE
.PP

.SS "void afcgi_init (int maxconn)"
.PP
init fcgi internals and poller system 
.PP
\fBParameters:\fP
.RS 4
\fImaxconn\fP The maximun of connection expected (all sockets) -1: use the max limit (ulimit -n) >0: use this value, ans set limit 
.RE
.PP

.SS "void afcgi_loop (int loop)"
.PP
afcgi main loop. This launched the main loop after initialization 
.PP
\fBParameters:\fP
.RS 4
\fIloop\fP (boolean) 0: the function return, 1: the function never return 
.RE
.PP

.SS "static void afcgi_set_arg (struct afcgi_sess * s, void * arg)\fC [inline, static]\fP"
.PP
set easy argument 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP fascgi session identifier 
.br
\fIarg\fP easy argument 
.RE
.PP

.SS "void afcgi_stop_write (struct afcgi_sess * s)"
.PP
afcgi session do not write more 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP afcgi session identifier 
.RE
.PP

.SS "void afcgi_want_write (struct afcgi_sess * s)"
.PP
afcgi session want's write 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP afcgi session identifier 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "enum \fBafcgi_return_status\fP \fBtm\fP"
.PP
return status 
.SH "Author"
.PP 
Generated automatically by Doxygen for events from the source code.
